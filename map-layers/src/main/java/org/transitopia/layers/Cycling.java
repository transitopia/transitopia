package org.transitopia.layers;

import com.onthegomap.planetiler.FeatureCollector;
import com.onthegomap.planetiler.FeatureMerge;
import com.onthegomap.planetiler.ForwardingProfile;
import com.onthegomap.planetiler.VectorTile;
import com.onthegomap.planetiler.config.PlanetilerConfig;
import com.onthegomap.planetiler.reader.SourceFeature;
import com.onthegomap.planetiler.reader.osm.OsmElement;
import com.onthegomap.planetiler.reader.osm.OsmRelationInfo;
import com.onthegomap.planetiler.util.MemoryEstimator;
import com.onthegomap.planetiler.util.ZoomFunction;

import java.io.IOException;
import java.io.InputStream;
import java.io.UncheckedIOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.graalvm.polyglot.Context;
import org.graalvm.polyglot.Source;
import org.graalvm.polyglot.Value;
import org.graalvm.polyglot.proxy.ProxyObject;


public class Cycling implements
    ForwardingProfile.LayerPostProcessor,
    ForwardingProfile.OsmRelationPreprocessor {

    static String JS_CODE;
    static {
        // Load OsmProcessor.js and include it in the .jar file for this program.
        try (InputStream in = Cycling.class.getResourceAsStream("/js/OsmProcessor.js")) {
            if (in == null) {
                throw new IllegalStateException("JS file not found on classpath");
            }
            JS_CODE = new String(in.readAllBytes(), StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    // ThreadLocal to hold per-thread JavaScript Context + function
    private final ThreadLocal<Value> jsHighwayFn = ThreadLocal.withInitial(() -> {
        try {
            // Load our JavaScript file from 'common-lib'. Both the option() and the ".mjs" extension are
            // required to access the 'exports' of the ES module.
            final Context ctx = Context.newBuilder("js").option("js.esm-eval-returns-exports", "true").build();
            final Source src = Source.newBuilder("js", JS_CODE, "script.mjs").build();
            return ctx.eval(src);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    });

    private final PlanetilerConfig config;
    private double BUFFER_SIZE = 4.0;
    // When zoomed out more than this, dont' encode any bike lane data whatsoever.
    private int MIN_ZOOM = 6;
    // When zoomed out more than this, don't encode details of the cycling paths (makes tiles too big)
    private int MIN_ZOOM_ATTR = 13;
    // Hide things like bike parking areas below this zoom level.
    private int MIN_ZOOM_DETAILS = 12;
    private static final String LAYER_NAME = "transitopia_cycling";
    // Minimum lengths for coalescing paths together at specific zoom levels
    private static final ZoomFunction.MeterToPixelThresholds MIN_LENGTH = ZoomFunction.meterThresholds()
        .put(7, 50)
        .put(6, 100)
        .put(5, 500)
        .put(4, 1_000);

    public Cycling(PlanetilerConfig config) {
        this.config = config;
    }

    @Override
    public String name() {
        return LAYER_NAME;
    }

    @Override
    public List<OsmRelationInfo> preprocessOsmRelation(OsmElement.Relation relation) {
        if (relation.hasTag("type", "route") && relation.hasTag("route", "bicycle")) {
            return List.of(new RouteRelationInfo(relation.id()));
        }
        return null;
    }

    public void processAllOsm(SourceFeature feature, FeatureCollector features) {
        if (feature.canBeLine()) {
            // Note: if we need to, we could do a preliminary filter here to see if this highway is cycling-ish, but it seems fine as-is.
            // On my MacBook it can process 3M ways/s using pure Java or 1M ways/s using JS, and it only changes the total time to process
            // the "british-columbia" region from 2s to 6s.
            final Value osmProcessessor = this.jsHighwayFn.get();
            final Value result = osmProcessessor.getMember("deriveCyclingTags").execute(feature.id(), ProxyObject.fromMap(feature.tags()));
            if (!result.isNull()) {
                // Create a linear feature in the new map tiles matching the current Way, with the computed tags:
                final var bikePath = features.line(LAYER_NAME)
                    .setBufferPixels(BUFFER_SIZE)
                    .setMinZoom(MIN_ZOOM);

                @SuppressWarnings("unchecked")
                Map<String, Object> tags = (Map<String, Object>) jsValueToJava(result);
                // Write the simplified tags generated by our JavaScript code. When not zoomed in a lot, we only
                // encode the "comfort" value since it's all that's needed to render the way on the map. At higher
                // zooms, we encode the details so users can click on it and get info about it.
                tags.forEach((k, v) -> bikePath.setAttrWithMinzoom(k, v, MIN_ZOOM_ATTR));
                bikePath.setAttr("comfort", tags.get("comfort"));

                // If this feature is a part of any routes, record that:
                var partOfRoutes = feature.relationInfo(RouteRelationInfo.class);
                if (!partOfRoutes.isEmpty()) {
                    var routeIdsString = "";
                    for (var relation : partOfRoutes) {
                        if (routeIdsString != "") routeIdsString += ",";
                        routeIdsString += relation.relation().id;
                    }
                    bikePath.setAttrWithMinzoom("routes", routeIdsString, MIN_ZOOM_ATTR);
                }
            }
        } else if (feature.isPoint()) {
            // Find bike rack/parking nodes
            if (feature.hasTag("amenity", "bicycle_parking")) {
                features.point(LAYER_NAME)
                    .setAttr("amenity", "bicycle_parking")
                    .setAttr("name", feature.getTag("name"))
                    .setAttr("osmNodeId", feature.id())
                    .setMinZoom(MIN_ZOOM_DETAILS);
            }
        }

        if (feature.canBePolygon()) {
            // Find bike rack/parking areas, e.g. https://www.openstreetmap.org/way/697625710
            if (feature.hasTag("amenity", "bicycle_parking")) {
                features.centroid(LAYER_NAME)
                    .setAttr("amenity", "bicycle_parking")
                    .setAttr("name", feature.getTag("name"))
                    .setAttr("osmWayId", feature.id())
                    .setMinZoom(MIN_ZOOM_DETAILS);
            }
        }
    }

    private record RouteRelationInfo(long id) implements OsmRelationInfo {

        @Override
        public long estimateMemoryUsageBytes() {
            return MemoryEstimator.CLASS_HEADER_BYTES + MemoryEstimator.estimateSizeLong(id);
        }
    }

    @Override
    public List<VectorTile.Feature> postProcess(int zoom, List<VectorTile.Feature> items) {
        final String LIMIT_MERGE_TAG = "noMerge";
        double tolerance = config.tolerance(zoom);
        double minLength = coalesce(MIN_LENGTH.apply(zoom), 0).doubleValue();

        // don't merge road segments with "oneway" tag
        // TODO: merge while preserving "oneway" instead ignoring
        int onewayId = 1;
        for (var item : items) {
            var oneway = item.tags().get("oneway");
            if (oneway instanceof Number n && n.intValue() == 1) {
                item.tags().put(LIMIT_MERGE_TAG, onewayId++);
            }
        }

        var merged = FeatureMerge.mergeLineStrings(items, minLength, tolerance, BUFFER_SIZE);

        for (var item : merged) {
            item.tags().remove(LIMIT_MERGE_TAG);
        }
        return merged;
    }

    private static <T> T coalesce(T a, T b) {
        return a != null ? a : b;
    }

    private static Object jsValueToJava(Value v) {
        if (v == null) {
            return null;
        }
        if (v.isNull()) {
            return null;
        }
        if (v.isBoolean()) {
            return v.asBoolean();
        }
        if (v.isNumber()) {
            double d = v.asDouble();
            if (Math.floor(d) == d && d >= Long.MIN_VALUE && d <= Long.MAX_VALUE) {
                return (long) d;
            } else {
                return d;
            }
        }
        if (v.isString()) {
            return v.asString();
        }
        if (v.hasArrayElements()) {
            List<Object> list = new ArrayList<>();
            for (long i = 0; i < v.getArraySize(); i++) {
                list.add(jsValueToJava(v.getArrayElement(i)));
            }
            return list;
        }
        if (v.hasMembers()) {
            Map<String, Object> map = new HashMap<>();
            for (String key : v.getMemberKeys()) {
                map.put(key, jsValueToJava(v.getMember(key)));
            }
            return map;
        }
        // fallback: just return as Object
        return v.as(Object.class);
    }
}
